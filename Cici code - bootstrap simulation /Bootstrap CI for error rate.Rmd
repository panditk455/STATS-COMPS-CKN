---
title: "Bootstrap confidence interval for error rate"
output: html_document
---

```{r}
compute_err <- function(dat) {
  definitive <- dat$Decision %in% c("ID","LeanID","Excl","LeanExcl")
  d <- dat[definitive, , drop = FALSE]
  if (nrow(d) == 0) return(NA_real_)

  mean(
    (d$Mating == "Nonmated" & d$Decision %in% c("ID","LeanID")) |
    (d$Mating == "Mated"    & d$Decision %in% c("Excl","LeanExcl")),
    na.rm = TRUE
  )
}

boot_rows <- function(df, B = 2000, seed = 123) {
  set.seed(seed)
  n <- nrow(df)
  vals <- numeric(B)
  for (b in 1:B) {
    idx <- sample.int(n, n, replace = TRUE)
    vals[b] <- compute_err(df[idx, ])
  }
  vals
}

vals1 <- boot_rows(responses, B = 2000)
quantile(vals1, c(.025, .975), na.rm = TRUE)

```

```{r}
boot_cluster <- function(df, cluster_var = "AnonID", B = 2000, seed = 123) {
  set.seed(seed)
  clusters <- unique(df[[cluster_var]])
  idx_by_cluster <- split(seq_len(nrow(df)), df[[cluster_var]])
  vals <- numeric(B)

  for (b in 1:B) {
    samp <- sample(clusters, length(clusters), replace = TRUE)
    idx <- unlist(idx_by_cluster[samp], use.names = FALSE)
    vals[b] <- compute_err(df[idx, ])
  }
  vals
}

vals2 <- boot_cluster(responses, cluster_var = "AnonID", B = 2000)
quantile(vals2, c(.025, .975), na.rm = TRUE) -> result

knitr::kable(result)
```

```{r}
vals3 <- boot_cluster(responses, cluster_var = "Cset", B = 2000)
quantile(vals3, c(.025, .975), na.rm = TRUE)

```

